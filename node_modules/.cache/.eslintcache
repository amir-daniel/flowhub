[{"C:\\Users\\97252\\Documents\\Projects\\river\\src\\index.js":"1","C:\\Users\\97252\\Documents\\Projects\\river\\src\\reportWebVitals.js":"2","C:\\Users\\97252\\Documents\\Projects\\river\\src\\App.js":"3","C:\\Users\\97252\\Documents\\Projects\\river\\src\\components\\ItemData.js":"4","C:\\Users\\97252\\Documents\\Projects\\river\\src\\components\\Timer.js":"5","C:\\Users\\97252\\Documents\\Projects\\river\\src\\components\\AnimatedCounter.js":"6"},{"size":500,"mtime":1641146692468,"results":"7","hashOfConfig":"8"},{"size":362,"mtime":1641146692873,"results":"9","hashOfConfig":"8"},{"size":4220,"mtime":1641374892014,"results":"10","hashOfConfig":"8"},{"size":6226,"mtime":1641332971524,"results":"11","hashOfConfig":"8"},{"size":2039,"mtime":1641334269293,"results":"12","hashOfConfig":"8"},{"size":2034,"mtime":1641326245950,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1xvy84z",{"filePath":"16","messages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"18","messages":"19","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"20","messages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22"},{"filePath":"23","messages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25"},{"filePath":"26","messages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28"},"C:\\Users\\97252\\Documents\\Projects\\river\\src\\index.js",[],"C:\\Users\\97252\\Documents\\Projects\\river\\src\\reportWebVitals.js",[],"C:\\Users\\97252\\Documents\\Projects\\river\\src\\App.js",["29","30","31"],"C:\\Users\\97252\\Documents\\Projects\\river\\src\\components\\ItemData.js",["32","33","34"],"/*global chrome*/\r\nimport styles from \"./ItemData.module.css\";\r\nimport AnimatedCounter from \"./AnimatedCounter\";\r\nimport Timer from \"./Timer.js\";\r\nimport { useRef, useEffect } from \"react\";\r\n\r\nconst playFile = (filepath) => {\r\n  var audioPlayer = new Audio(chrome.runtime.getURL(filepath));\r\n  audioPlayer.play();\r\n};\r\nconst designDigit = (num) => (+num < 10 ? \"0\" + num : num);\r\nconst beautify = (time) => {\r\n  time = Math.floor(time); // round time received in seconds\r\n\r\n  let sec = designDigit(time % 60);\r\n  let min = designDigit(((time - sec) / 60) % 60);\r\n  let hr = (time - sec - 60 * min) / 3600;\r\n\r\n  return `${hr}h${min}m${sec}s`;\r\n};\r\n\r\nconst ItemData = (props) => {\r\n  const inputRef = useRef(null);\r\n\r\n  // useEffect(() => {\r\n  //   if (inputRef.current) {\r\n  //     inputRef.current.focus();\r\n  //   }\r\n  // }, []);\r\n\r\n  const progressHandler = (event) => {\r\n    if (+props.itemMax === +event.target.value) {\r\n      playFile(\"sounds/complete.mp3\");\r\n      return;\r\n    }\r\n    playFile(\"sounds/increment.mp3\");\r\n  };\r\n\r\n  const getETA = () => {\r\n    let totalProgress = props.progress - props.itemMin;\r\n    let progressLeft = props.itemMax - props.progress;\r\n    let totalMins = props.time.current / 60;\r\n\r\n    if (\r\n      !props.timerID.current &\r\n      (props.progress === props.itemMin ||\r\n        props.itemMax != props.progress ||\r\n        props.progress === null || // these 3 nulls are to wait for the data to load\r\n        props.itemMax === null ||\r\n        props.itemMin === null)\r\n    ) {\r\n      return \"\";\r\n    }\r\n\r\n    if (\r\n      props.timerID.current &&\r\n      (props.time.current < 1 || totalProgress === 0)\r\n    ) {\r\n      return \" ‚àû\";\r\n    }\r\n\r\n    if (progressLeft === 0) {\r\n      if (props.timerID.current) {\r\n        clearInterval(props.timerID.current);\r\n        props.setTimerID(false);\r\n      }\r\n      return \" ‚úÖ\";\r\n    }\r\n\r\n    let paceInMins = totalProgress / totalMins;\r\n    let minsPerItem = 1 / paceInMins;\r\n    let minsLeft = minsPerItem * progressLeft;\r\n    let millisecondsLeft = minsLeft * 60 * 1000;\r\n    let ETADate = new Date(Date.now() + millisecondsLeft);\r\n    let dateFormatted = (\r\n      <span>\r\n        {\" \"}\r\n        <AnimatedCounter\r\n          key={\"h\"}\r\n          value={ETADate.getHours()}\r\n          inc={1}\r\n          refreshRate={24}\r\n          callback={designDigit}\r\n        />\r\n        :\r\n        <AnimatedCounter\r\n          key={\"m\"}\r\n          value={designDigit(ETADate.getMinutes())}\r\n          inc={1}\r\n          refreshRate={8}\r\n          callback={designDigit}\r\n        />\r\n      </span>\r\n    );\r\n\r\n    return dateFormatted;\r\n  };\r\n\r\n  const getPercentage = () => {\r\n    let totalProgressMade = props.progress - props.itemMin;\r\n    let totalProgressPossible = props.itemMax - props.itemMin;\r\n\r\n    if (\r\n      totalProgressPossible === 0 ||\r\n      props.progress === null ||\r\n      props.itemMax === null ||\r\n      props.itemMin === null\r\n    ) {\r\n      // wait when data is loading\r\n      return 0;\r\n    }\r\n\r\n    return 100 * (totalProgressMade / totalProgressPossible);\r\n  };\r\n\r\n  return (\r\n    <form onSubmit={(event) => event.preventDefault()}>\r\n      <input\r\n        style={{ width: `2.7em` }}\r\n        type=\"number\"\r\n        className={styles.items}\r\n        min=\"0\"\r\n        step=\"1\"\r\n        onChange={props.onMinChange}\r\n        value={props.itemMin}\r\n        disabled={props.timerID.current}\r\n      />\r\n      <input\r\n        className={styles.items}\r\n        style={{ width: `2.7em` }}\r\n        type=\"number\"\r\n        onChange={(event) => {\r\n          props.onCurrentChange(event);\r\n          progressHandler(event);\r\n        }}\r\n        min=\"0\"\r\n        step=\"1\"\r\n        value={props.progress}\r\n        disabled={props.timerID.current !== false}\r\n      />\r\n      <input\r\n        className={styles.items}\r\n        style={{ width: `2.7em` }}\r\n        type=\"number\"\r\n        onChange={props.onMaxChange}\r\n        value={props.itemMax}\r\n        min=\"0\"\r\n        step=\"1\"\r\n        disabled={props.timerID.current}\r\n      />\r\n\r\n      <br />\r\n      <br />\r\n      <Timer\r\n        timerID={props.timerID}\r\n        modifyTimerID={props.setTimerID}\r\n        onTick={() => {\r\n          inputRef.current.focus();\r\n          props.onTick();\r\n        }}\r\n        isResettable={\r\n          props.time.current >= 1 || props.progress != props.itemMin\r\n        }\r\n        onReset={props.onReset}\r\n        value={props.time}\r\n      />\r\n      <button\r\n        autofocus=\"true\"\r\n        ref={inputRef}\r\n        onClick={() => {\r\n          props.onCurrentChange({ target: { value: props.progress + 1 } });\r\n          progressHandler({ target: { value: props.progress + 1 } });\r\n        }}\r\n        type=\"submit\"\r\n        disabled={+props.progress === +props.itemMax}\r\n      >\r\n        ‚¨ÜÔ∏è\r\n      </button>\r\n      <span\r\n\r\n      // style={{\r\n      //   color: props.timerID.current\r\n      //     ? getPercentage() < 100\r\n      //       ? getPercentage() < 50\r\n      //         ? \"rgb(197, 52, 52)\"\r\n      //         : \"rgb(209, 135, 51)\"\r\n      //       : \"rgb(32, 189, 17)\"\r\n      //     : props.progress === props.itemMax && props.itemMax !== 0\r\n      //     ? \"rgb(32, 189, 17)\"\r\n      //     : \"rgb(255,255,255)\",\r\n      // }\r\n      >\r\n        <br />\r\n        <br />\r\n        <div style={{ fontSize: \"0.9em\" }}>\r\n          {beautify(props.time.current)}\r\n          {`${\r\n            props.timerID.current === false ||\r\n            props.progress === null || // these 3 nulls are to wait for the data to load\r\n            props.itemMax === null ||\r\n            props.itemMin === null\r\n              ? \"\"\r\n              : \"üî¥\"\r\n          }`}\r\n          {getETA()}\r\n        </div>\r\n      </span>\r\n      <br />\r\n      <div class={styles.progress}>\r\n        <div\r\n          className={styles[`progress-value`]}\r\n          style={{\r\n            width: getPercentage() + \"%\",\r\n            background:\r\n              getPercentage() < 100\r\n                ? getPercentage() < 50\r\n                  ? \"rgb(197, 52, 52)\"\r\n                  : \"rgb(209, 135, 51)\"\r\n                : \"rgb(32, 189, 17)\",\r\n          }}\r\n        >\r\n          <AnimatedCounter value={getPercentage()} />%\r\n        </div>\r\n      </div>\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default ItemData;\r\n","C:\\Users\\97252\\Documents\\Projects\\river\\src\\components\\Timer.js",["35"],"/*global chrome*/\r\nimport { useEffect } from \"react\";\r\nconst Timer = (props) => {\r\n  const tickHandler = () => {\r\n    props.onTick();\r\n  };\r\n\r\n  const startHandler = () => {\r\n    if (props.timerID.current === false) {\r\n      props.modifyTimerID(\r\n        setInterval(() => {\r\n          tickHandler();\r\n        }, 1000)\r\n      );\r\n      chrome.storage.sync.get([\"startedRecordingAt\", \"savedTime\"], (data) => {\r\n        if (data.startedRecordingAt === null && data.savedTime === null) {\r\n          chrome.storage.sync.set({\r\n            startedRecordingAt: Date.now(),\r\n          });\r\n        } else {\r\n          chrome.storage.sync.get([\"startedRecordingAt\"], (data) => {});\r\n\r\n          chrome.storage.sync.set({\r\n            startedRecordingAt: Date.now() - props.value.current * 1000,\r\n            savedTime: null,\r\n          });\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  const stopHandler = () => {\r\n    clearInterval(props.timerID.current);\r\n    props.modifyTimerID(false);\r\n\r\n    chrome.storage.sync.set({\r\n      startedRecordingAt: null,\r\n      savedTime: props.value.current,\r\n    });\r\n  };\r\n\r\n  const resetHandler = () => {\r\n    // stopHandler(); // pause time recording\r\n    clearInterval(props.timerID.current);\r\n    props.modifyTimerID(false);\r\n    props.onReset(); // remove time recorded -> reset === true\r\n\r\n    chrome.storage.sync.set({\r\n      startedRecordingAt: null,\r\n      savedTime: null,\r\n    });\r\n  };\r\n\r\n  useEffect(() => {\r\n    chrome.storage.sync.get([\"startedRecordingAt\", \"savedTime\"], (data) => {\r\n      if (data.startedRecordingAt !== null && data.savedTime === null) {\r\n        startHandler();\r\n      }\r\n    });\r\n  }, []);\r\n\r\n  return (\r\n    <span>\r\n      <button disabled={!props.isResettable} onClick={resetHandler}>\r\n        ‚èπÔ∏è\r\n      </button>\r\n      <button disabled={!props.timerID.current} onClick={stopHandler}>\r\n        ‚è∏Ô∏è\r\n      </button>\r\n      <button disabled={props.timerID.current} onClick={startHandler}>\r\n        ‚ñ∂Ô∏è\r\n      </button>\r\n    </span>\r\n  );\r\n};\r\n\r\nexport default Timer;\r\n","C:\\Users\\97252\\Documents\\Projects\\river\\src\\components\\AnimatedCounter.js",["36"],"import react from \"react\";\r\nimport { useState, useRef } from \"react\";\r\n\r\nconst AnimatedCounter = (props) => {\r\n  const [getOldValue, setOldValue] = useState(0); //useState(props.value);\r\n  const [timerID, setTimerID] = useState(false);\r\n  let oldValue = useRef();\r\n  oldValue.current = getOldValue;\r\n  const delayInSeconds = 2;\r\n  const refreshPerSecond =\r\n    props.refreshRate === undefined ? 25 : props.refreshRate; // default refresh rate is 25 Hz\r\n  const sign = (number) => (number < 0 ? -1 : 1);\r\n\r\n  const executeTick = (oldVal, incSize) => {\r\n    if (\r\n      (+oldVal + +incSize) * sign(+incSize) >=\r\n      +props.value * sign(+incSize)\r\n    ) {\r\n      // we've finished incrementing, let's reset the timer and oldValue\r\n      setOldValue(props.value);\r\n\r\n      clearTimeout(timerID);\r\n      setTimerID(false);\r\n    } else {\r\n      setOldValue(oldVal + incSize);\r\n\r\n      setTimerID(\r\n        setTimeout(\r\n          () => executeTick(oldVal + incSize, incSize),\r\n          1000 * (1 / refreshPerSecond)\r\n        )\r\n      );\r\n    }\r\n  };\r\n\r\n  let expression;\r\n  if (+oldValue.current !== +props.value && !timerID) {\r\n    // we get new value, set up increment\r\n    let tempInc =\r\n      (+props.value - +oldValue.current) / (delayInSeconds * refreshPerSecond);\r\n    tempInc = props.inc === undefined ? tempInc : props.inc * sign(tempInc);\r\n    // set minimum increment, if defined\r\n    setTimerID(\r\n      setTimeout(\r\n        () => executeTick(oldValue.current + tempInc, tempInc),\r\n        1000 * (1 / refreshPerSecond)\r\n      )\r\n    );\r\n\r\n    expression = Math.floor(100 * (oldValue.current + tempInc)) / 100;\r\n    return (\r\n      (props.callback === undefined\r\n        ? expression\r\n        : props.callback(expression)) || oldValue.current\r\n    );\r\n    // run the callback on expression if defined\r\n  }\r\n\r\n  expression = Math.floor(100 * oldValue.current) / 100;\r\n  return (\r\n    (props.callback === undefined ? expression : props.callback(expression)) ||\r\n    oldValue.current\r\n  );\r\n};\r\n\r\nexport default AnimatedCounter;\r\n",{"ruleId":"37","severity":1,"message":"38","line":4,"column":8,"nodeType":"39","messageId":"40","endLine":4,"endColumn":13},{"ruleId":"37","severity":1,"message":"41","line":5,"column":8,"nodeType":"39","messageId":"40","endLine":5,"endColumn":13},{"ruleId":"42","severity":1,"message":"43","line":91,"column":11,"nodeType":"44","endLine":133,"endColumn":13},{"ruleId":"37","severity":1,"message":"45","line":5,"column":18,"nodeType":"39","messageId":"40","endLine":5,"endColumn":27},{"ruleId":"46","severity":1,"message":"47","line":47,"column":23,"nodeType":"48","messageId":"49","endLine":47,"endColumn":25},{"ruleId":"46","severity":1,"message":"47","line":162,"column":53,"nodeType":"48","messageId":"49","endLine":162,"endColumn":55},{"ruleId":"50","severity":1,"message":"51","line":60,"column":6,"nodeType":"52","endLine":60,"endColumn":8,"suggestions":"53"},{"ruleId":"37","severity":1,"message":"41","line":1,"column":8,"nodeType":"39","messageId":"40","endLine":1,"endColumn":13},"no-unused-vars","'Timer' is defined but never used.","Identifier","unusedVar","'react' is defined but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'useEffect' is defined but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'startHandler'. Either include it or remove the dependency array.","ArrayExpression",["54"],{"desc":"55","fix":"56"},"Update the dependencies array to be: [startHandler]",{"range":"57","text":"58"},[1646,1648],"[startHandler]"]