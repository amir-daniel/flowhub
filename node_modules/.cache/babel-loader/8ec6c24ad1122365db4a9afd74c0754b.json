{"ast":null,"code":"import _slicedToArray from\"C:\\\\Users\\\\97252\\\\Documents\\\\Projects\\\\river\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";import react from\"react\";import{useState,useRef}from\"react\";var AnimatedCounter=function AnimatedCounter(props){var _useState=useState(0),_useState2=_slicedToArray(_useState,2),getOldValue=_useState2[0],setOldValue=_useState2[1];//useState(props.value);\nvar _useState3=useState(false),_useState4=_slicedToArray(_useState3,2),timerID=_useState4[0],setTimerID=_useState4[1];var oldValue=useRef();oldValue.current=getOldValue;var delayInSeconds=2;var refreshPerSecond=props.refreshRate===undefined?25:props.refreshRate;// default refresh rate is 25 Hz\nvar sign=function sign(number){return number<0?-1:1;};var executeTick=function executeTick(oldVal,incSize){if((+oldVal+ +incSize)*sign(+incSize)>=+props.value*sign(+incSize)){// we've finished incrementing, let's reset the timer and oldValue\nsetOldValue(props.value);clearTimeout(timerID);setTimerID(false);}else{setOldValue(oldVal+incSize);setTimerID(setTimeout(function(){return executeTick(oldVal+incSize,incSize);},1000*(1/refreshPerSecond)));}};var expression;if(+oldValue.current!==+props.value&&!timerID){// we get new value, set up increment\nvar tempInc=(+props.value-+oldValue.current)/(delayInSeconds*refreshPerSecond);tempInc=props.inc===undefined?tempInc:props.inc;// set minimum increment, if defined\nsetTimerID(setTimeout(function(){return executeTick(oldValue.current+tempInc,tempInc);},1000*(1/refreshPerSecond)));expression=Math.floor(100*(oldValue.current+tempInc))/100;return props.callback===undefined?expression:props.callback(expression);// run the callback on expression if defined\n}expression=Math.floor(100*oldValue.current)/100;return props.callback===undefined?expression:props.callback(expression);};export default AnimatedCounter;","map":{"version":3,"sources":["C:/Users/97252/Documents/Projects/river/src/components/AnimatedCounter.js"],"names":["react","useState","useRef","AnimatedCounter","props","getOldValue","setOldValue","timerID","setTimerID","oldValue","current","delayInSeconds","refreshPerSecond","refreshRate","undefined","sign","number","executeTick","oldVal","incSize","value","clearTimeout","setTimeout","expression","tempInc","inc","Math","floor","callback"],"mappings":"wIAAA,MAAOA,CAAAA,KAAP,KAAkB,OAAlB,CACA,OAASC,QAAT,CAAmBC,MAAnB,KAAiC,OAAjC,CAEA,GAAMC,CAAAA,eAAe,CAAG,QAAlBA,CAAAA,eAAkB,CAACC,KAAD,CAAW,CACjC,cAAmCH,QAAQ,CAAC,CAAD,CAA3C,wCAAOI,WAAP,eAAoBC,WAApB,eAAgD;AAChD,eAA8BL,QAAQ,CAAC,KAAD,CAAtC,yCAAOM,OAAP,eAAgBC,UAAhB,eACA,GAAIC,CAAAA,QAAQ,CAAGP,MAAM,EAArB,CACAO,QAAQ,CAACC,OAAT,CAAmBL,WAAnB,CACA,GAAMM,CAAAA,cAAc,CAAG,CAAvB,CACA,GAAMC,CAAAA,gBAAgB,CACpBR,KAAK,CAACS,WAAN,GAAsBC,SAAtB,CAAkC,EAAlC,CAAuCV,KAAK,CAACS,WAD/C,CAC4D;AAC5D,GAAME,CAAAA,IAAI,CAAG,QAAPA,CAAAA,IAAO,CAACC,MAAD,QAAaA,CAAAA,MAAM,CAAG,CAAT,CAAa,CAAC,CAAd,CAAkB,CAA/B,EAAb,CAEA,GAAMC,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CAACC,MAAD,CAASC,OAAT,CAAqB,CACvC,GACE,CAAC,CAACD,MAAD,CAAU,EAACC,OAAZ,EAAuBJ,IAAI,CAAC,CAACI,OAAF,CAA3B,EACA,CAACf,KAAK,CAACgB,KAAP,CAAeL,IAAI,CAAC,CAACI,OAAF,CAFrB,CAGE,CACA;AACAb,WAAW,CAACF,KAAK,CAACgB,KAAP,CAAX,CAEAC,YAAY,CAACd,OAAD,CAAZ,CACAC,UAAU,CAAC,KAAD,CAAV,CACD,CATD,IASO,CACLF,WAAW,CAACY,MAAM,CAAGC,OAAV,CAAX,CAEAX,UAAU,CACRc,UAAU,CACR,iBAAML,CAAAA,WAAW,CAACC,MAAM,CAAGC,OAAV,CAAmBA,OAAnB,CAAjB,EADQ,CAER,MAAQ,EAAIP,gBAAZ,CAFQ,CADF,CAAV,CAMD,CACF,CApBD,CAsBA,GAAIW,CAAAA,UAAJ,CACA,GAAI,CAACd,QAAQ,CAACC,OAAV,GAAsB,CAACN,KAAK,CAACgB,KAA7B,EAAsC,CAACb,OAA3C,CAAoD,CAClD;AACA,GAAIiB,CAAAA,OAAO,CACT,CAAC,CAACpB,KAAK,CAACgB,KAAP,CAAe,CAACX,QAAQ,CAACC,OAA1B,GAAsCC,cAAc,CAAGC,gBAAvD,CADF,CAEAY,OAAO,CAAGpB,KAAK,CAACqB,GAAN,GAAcX,SAAd,CAA0BU,OAA1B,CAAoCpB,KAAK,CAACqB,GAApD,CACA;AACAjB,UAAU,CACRc,UAAU,CACR,iBAAML,CAAAA,WAAW,CAACR,QAAQ,CAACC,OAAT,CAAmBc,OAApB,CAA6BA,OAA7B,CAAjB,EADQ,CAER,MAAQ,EAAIZ,gBAAZ,CAFQ,CADF,CAAV,CAOAW,UAAU,CAAGG,IAAI,CAACC,KAAL,CAAW,KAAOlB,QAAQ,CAACC,OAAT,CAAmBc,OAA1B,CAAX,EAAiD,GAA9D,CACA,MAAOpB,CAAAA,KAAK,CAACwB,QAAN,GAAmBd,SAAnB,CACHS,UADG,CAEHnB,KAAK,CAACwB,QAAN,CAAeL,UAAf,CAFJ,CAGA;AACD,CAEDA,UAAU,CAAGG,IAAI,CAACC,KAAL,CAAW,IAAMlB,QAAQ,CAACC,OAA1B,EAAqC,GAAlD,CACA,MAAON,CAAAA,KAAK,CAACwB,QAAN,GAAmBd,SAAnB,CAA+BS,UAA/B,CAA4CnB,KAAK,CAACwB,QAAN,CAAeL,UAAf,CAAnD,CACD,CAvDD,CAyDA,cAAepB,CAAAA,eAAf","sourcesContent":["import react from \"react\";\r\nimport { useState, useRef } from \"react\";\r\n\r\nconst AnimatedCounter = (props) => {\r\n  const [getOldValue, setOldValue] = useState(0); //useState(props.value);\r\n  const [timerID, setTimerID] = useState(false);\r\n  let oldValue = useRef();\r\n  oldValue.current = getOldValue;\r\n  const delayInSeconds = 2;\r\n  const refreshPerSecond =\r\n    props.refreshRate === undefined ? 25 : props.refreshRate; // default refresh rate is 25 Hz\r\n  const sign = (number) => (number < 0 ? -1 : 1);\r\n\r\n  const executeTick = (oldVal, incSize) => {\r\n    if (\r\n      (+oldVal + +incSize) * sign(+incSize) >=\r\n      +props.value * sign(+incSize)\r\n    ) {\r\n      // we've finished incrementing, let's reset the timer and oldValue\r\n      setOldValue(props.value);\r\n\r\n      clearTimeout(timerID);\r\n      setTimerID(false);\r\n    } else {\r\n      setOldValue(oldVal + incSize);\r\n\r\n      setTimerID(\r\n        setTimeout(\r\n          () => executeTick(oldVal + incSize, incSize),\r\n          1000 * (1 / refreshPerSecond)\r\n        )\r\n      );\r\n    }\r\n  };\r\n\r\n  let expression;\r\n  if (+oldValue.current !== +props.value && !timerID) {\r\n    // we get new value, set up increment\r\n    let tempInc =\r\n      (+props.value - +oldValue.current) / (delayInSeconds * refreshPerSecond);\r\n    tempInc = props.inc === undefined ? tempInc : props.inc;\r\n    // set minimum increment, if defined\r\n    setTimerID(\r\n      setTimeout(\r\n        () => executeTick(oldValue.current + tempInc, tempInc),\r\n        1000 * (1 / refreshPerSecond)\r\n      )\r\n    );\r\n\r\n    expression = Math.floor(100 * (oldValue.current + tempInc)) / 100;\r\n    return props.callback === undefined\r\n      ? expression\r\n      : props.callback(expression);\r\n    // run the callback on expression if defined\r\n  }\r\n\r\n  expression = Math.floor(100 * oldValue.current) / 100;\r\n  return props.callback === undefined ? expression : props.callback(expression);\r\n};\r\n\r\nexport default AnimatedCounter;\r\n"]},"metadata":{},"sourceType":"module"}