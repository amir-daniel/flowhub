{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport react from \"react\";\nimport { useState } from \"react\";\n\nconst AnimatedCounter = props => {\n  _s();\n\n  const [oldValue, setOldValue] = useState(0); //useState(props.value);\n\n  const [incrementSize, setIncrementSize] = useState(0);\n  const [timerID, setTimerID] = useState(false);\n  const delayInSeconds = 3;\n  const refreshPerSecond = 3;\n\n  const sign = number => number < 0 ? -1 : 1;\n\n  const executeTick = () => {\n    setOldValue(oldValue + incrementSize);\n    alert(\"lol\");\n    setTimerID(setTimeout(() => setOldValue(prevState => prevState + incrementSize), 1000));\n  };\n\n  if ((+oldValue + incrementSize) * sign(incrementSize) >= +props.value * sign(incrementSize) && incrementSize !== 0) {\n    alert(\"first\"); // we've finished incrementing, let's reset incrementSize\n\n    setIncrementSize(0);\n    clearTimeout(timerID);\n    setTimerID(false);\n  }\n\n  if (+oldValue !== +props.value && incrementSize === 0) {\n    alert(\"second\"); // we get new value, set up increment\n\n    setIncrementSize((props.value - oldValue) / 2);\n\n    if (!timerID) {\n      alert(\"in\");\n      setTimerID(setTimeout(() => executeTick(), 1000));\n    }\n  }\n\n  return oldValue + incrementSize + props.value;\n}; //   const tickHandler = async (oldVal, newVal) => {\n//     const delayInSeconds = 3;\n//     const Herz = 25;\n//     const incrementSize = (newVal - oldVal) / (delayInSeconds * Herz);\n//     // for (let i = 1; i < delayInSeconds * Herz; i++) {\n//     //   await setTimeout(\n//     //     () => setOldValue(oldVal + i * incrementSize),\n//     //     1000 / Herz\n//     //   );\n//     // }\n//     // await setTimeout(() => setOldValue(newVal), 1000 / Herz);\n//   };\n\n\n_s(AnimatedCounter, \"ee7YzNH/GvarXiQicnzX5/49Y2E=\");\n\n_c = AnimatedCounter;\nexport default AnimatedCounter;\n\nvar _c;\n\n$RefreshReg$(_c, \"AnimatedCounter\");","map":{"version":3,"sources":["C:/Users/97252/Documents/Projects/river/src/components/AnimatedCounter.js"],"names":["react","useState","AnimatedCounter","props","oldValue","setOldValue","incrementSize","setIncrementSize","timerID","setTimerID","delayInSeconds","refreshPerSecond","sign","number","executeTick","alert","setTimeout","prevState","value","clearTimeout"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,QAAT,QAAyB,OAAzB;;AAEA,MAAMC,eAAe,GAAIC,KAAD,IAAW;AAAA;;AACjC,QAAM,CAACC,QAAD,EAAWC,WAAX,IAA0BJ,QAAQ,CAAC,CAAD,CAAxC,CADiC,CACY;;AAC7C,QAAM,CAACK,aAAD,EAAgBC,gBAAhB,IAAoCN,QAAQ,CAAC,CAAD,CAAlD;AACA,QAAM,CAACO,OAAD,EAAUC,UAAV,IAAwBR,QAAQ,CAAC,KAAD,CAAtC;AAEA,QAAMS,cAAc,GAAG,CAAvB;AACA,QAAMC,gBAAgB,GAAG,CAAzB;;AACA,QAAMC,IAAI,GAAIC,MAAD,IAAaA,MAAM,GAAG,CAAT,GAAa,CAAC,CAAd,GAAkB,CAA5C;;AAEA,QAAMC,WAAW,GAAG,MAAM;AACxBT,IAAAA,WAAW,CAACD,QAAQ,GAAGE,aAAZ,CAAX;AACAS,IAAAA,KAAK,CAAC,KAAD,CAAL;AACAN,IAAAA,UAAU,CACRO,UAAU,CACR,MAAMX,WAAW,CAAEY,SAAD,IAAeA,SAAS,GAAGX,aAA5B,CADT,EAER,IAFQ,CADF,CAAV;AAMD,GATD;;AAWA,MACE,CAAC,CAACF,QAAD,GAAYE,aAAb,IAA8BM,IAAI,CAACN,aAAD,CAAlC,IACE,CAACH,KAAK,CAACe,KAAP,GAAeN,IAAI,CAACN,aAAD,CADrB,IAEAA,aAAa,KAAK,CAHpB,EAIE;AACAS,IAAAA,KAAK,CAAC,OAAD,CAAL,CADA,CAEA;;AACAR,IAAAA,gBAAgB,CAAC,CAAD,CAAhB;AACAY,IAAAA,YAAY,CAACX,OAAD,CAAZ;AACAC,IAAAA,UAAU,CAAC,KAAD,CAAV;AACD;;AACD,MAAI,CAACL,QAAD,KAAc,CAACD,KAAK,CAACe,KAArB,IAA8BZ,aAAa,KAAK,CAApD,EAAuD;AACrDS,IAAAA,KAAK,CAAC,QAAD,CAAL,CADqD,CAErD;;AACAR,IAAAA,gBAAgB,CAAC,CAACJ,KAAK,CAACe,KAAN,GAAcd,QAAf,IAA2B,CAA5B,CAAhB;;AACA,QAAI,CAACI,OAAL,EAAc;AACZO,MAAAA,KAAK,CAAC,IAAD,CAAL;AACAN,MAAAA,UAAU,CAACO,UAAU,CAAC,MAAMF,WAAW,EAAlB,EAAsB,IAAtB,CAAX,CAAV;AACD;AACF;;AAED,SAAOV,QAAQ,GAAGE,aAAX,GAA2BH,KAAK,CAACe,KAAxC;AACD,CA1CD,C,CA4CA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;GAzDMhB,e;;KAAAA,e;AA2DN,eAAeA,eAAf","sourcesContent":["import react from \"react\";\r\nimport { useState } from \"react\";\r\n\r\nconst AnimatedCounter = (props) => {\r\n  const [oldValue, setOldValue] = useState(0); //useState(props.value);\r\n  const [incrementSize, setIncrementSize] = useState(0);\r\n  const [timerID, setTimerID] = useState(false);\r\n\r\n  const delayInSeconds = 3;\r\n  const refreshPerSecond = 3;\r\n  const sign = (number) => (number < 0 ? -1 : 1);\r\n\r\n  const executeTick = () => {\r\n    setOldValue(oldValue + incrementSize);\r\n    alert(\"lol\");\r\n    setTimerID(\r\n      setTimeout(\r\n        () => setOldValue((prevState) => prevState + incrementSize),\r\n        1000\r\n      )\r\n    );\r\n  };\r\n\r\n  if (\r\n    (+oldValue + incrementSize) * sign(incrementSize) >=\r\n      +props.value * sign(incrementSize) &&\r\n    incrementSize !== 0\r\n  ) {\r\n    alert(\"first\");\r\n    // we've finished incrementing, let's reset incrementSize\r\n    setIncrementSize(0);\r\n    clearTimeout(timerID);\r\n    setTimerID(false);\r\n  }\r\n  if (+oldValue !== +props.value && incrementSize === 0) {\r\n    alert(\"second\");\r\n    // we get new value, set up increment\r\n    setIncrementSize((props.value - oldValue) / 2);\r\n    if (!timerID) {\r\n      alert(\"in\");\r\n      setTimerID(setTimeout(() => executeTick(), 1000));\r\n    }\r\n  }\r\n\r\n  return oldValue + incrementSize + props.value;\r\n};\r\n\r\n//   const tickHandler = async (oldVal, newVal) => {\r\n//     const delayInSeconds = 3;\r\n\r\n//     const Herz = 25;\r\n//     const incrementSize = (newVal - oldVal) / (delayInSeconds * Herz);\r\n\r\n//     // for (let i = 1; i < delayInSeconds * Herz; i++) {\r\n//     //   await setTimeout(\r\n//     //     () => setOldValue(oldVal + i * incrementSize),\r\n//     //     1000 / Herz\r\n//     //   );\r\n//     // }\r\n//     // await setTimeout(() => setOldValue(newVal), 1000 / Herz);\r\n//   };\r\n\r\nexport default AnimatedCounter;\r\n"]},"metadata":{},"sourceType":"module"}