{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport react from \"react\";\nimport { useState, useRef } from \"react\";\n\nconst AnimatedCounter = props => {\n  _s();\n\n  const [getOldValue, setOldValue] = useState(0); //useState(props.value);\n\n  const [timerID, setTimerID] = useState(false);\n  let oldValue = useRef();\n  oldValue.current = getOldValue;\n  const delayInSeconds = 2;\n  const refreshPerSecond = props.refreshRate === undefined ? 25 : props.refreshRate; // default refresh rate is 25 Hz\n\n  const sign = number => number < 0 ? -1 : 1;\n\n  const executeTick = (oldVal, incSize) => {\n    if ((+oldVal + +incSize) * sign(+incSize) >= +props.value * sign(+incSize)) {\n      // we've finished incrementing, let's reset the timer and oldValue\n      setOldValue(props.value);\n      clearTimeout(timerID);\n      setTimerID(false);\n    } else {\n      setOldValue(oldVal + incSize);\n      setTimerID(setTimeout(() => executeTick(oldVal + incSize, incSize), 1000 * (1 / refreshPerSecond)));\n    }\n  };\n\n  let expression;\n\n  if (+oldValue.current !== +props.value && !timerID) {\n    // we get new value, set up increment\n    let tempInc = (+props.value - +oldValue.current) / (delayInSeconds * refreshPerSecond);\n    tempInc = props.inc === undefined ? tempInc : props.inc * sign(tempInc); // set minimum increment, if defined\n\n    setTimerID(setTimeout(() => executeTick(oldValue.current + tempInc, tempInc), 1000 * (1 / refreshPerSecond)));\n    expression = Math.floor(100 * (oldValue.current + tempInc)) / 100;\n    return (props.callback === undefined ? expression : props.callback(expression)) || oldValue.current; // run the callback on expression if defined\n  }\n\n  expression = Math.floor(100 * oldValue.current) / 100;\n  return (props.callback === undefined ? expression : props.callback(expression)) || oldValue.current;\n};\n\n_s(AnimatedCounter, \"28EVzZbN7aw3sMDLhmIdjcuLaiw=\");\n\n_c = AnimatedCounter;\nexport default AnimatedCounter;\n\nvar _c;\n\n$RefreshReg$(_c, \"AnimatedCounter\");","map":{"version":3,"sources":["C:/Users/97252/Documents/Projects/river/src/components/AnimatedCounter.js"],"names":["react","useState","useRef","AnimatedCounter","props","getOldValue","setOldValue","timerID","setTimerID","oldValue","current","delayInSeconds","refreshPerSecond","refreshRate","undefined","sign","number","executeTick","oldVal","incSize","value","clearTimeout","setTimeout","expression","tempInc","inc","Math","floor","callback"],"mappings":"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","sourcesContent":["import react from \"react\";\r\nimport { useState, useRef } from \"react\";\r\n\r\nconst AnimatedCounter = (props) => {\r\n  const [getOldValue, setOldValue] = useState(0); //useState(props.value);\r\n  const [timerID, setTimerID] = useState(false);\r\n  let oldValue = useRef();\r\n  oldValue.current = getOldValue;\r\n  const delayInSeconds = 2;\r\n  const refreshPerSecond =\r\n    props.refreshRate === undefined ? 25 : props.refreshRate; // default refresh rate is 25 Hz\r\n  const sign = (number) => (number < 0 ? -1 : 1);\r\n\r\n  const executeTick = (oldVal, incSize) => {\r\n    if (\r\n      (+oldVal + +incSize) * sign(+incSize) >=\r\n      +props.value * sign(+incSize)\r\n    ) {\r\n      // we've finished incrementing, let's reset the timer and oldValue\r\n      setOldValue(props.value);\r\n\r\n      clearTimeout(timerID);\r\n      setTimerID(false);\r\n    } else {\r\n      setOldValue(oldVal + incSize);\r\n\r\n      setTimerID(\r\n        setTimeout(\r\n          () => executeTick(oldVal + incSize, incSize),\r\n          1000 * (1 / refreshPerSecond)\r\n        )\r\n      );\r\n    }\r\n  };\r\n\r\n  let expression;\r\n  if (+oldValue.current !== +props.value && !timerID) {\r\n    // we get new value, set up increment\r\n    let tempInc =\r\n      (+props.value - +oldValue.current) / (delayInSeconds * refreshPerSecond);\r\n    tempInc = props.inc === undefined ? tempInc : props.inc * sign(tempInc);\r\n    // set minimum increment, if defined\r\n    setTimerID(\r\n      setTimeout(\r\n        () => executeTick(oldValue.current + tempInc, tempInc),\r\n        1000 * (1 / refreshPerSecond)\r\n      )\r\n    );\r\n\r\n    expression = Math.floor(100 * (oldValue.current + tempInc)) / 100;\r\n    return (\r\n      (props.callback === undefined\r\n        ? expression\r\n        : props.callback(expression)) || oldValue.current\r\n    );\r\n    // run the callback on expression if defined\r\n  }\r\n\r\n  expression = Math.floor(100 * oldValue.current) / 100;\r\n  return (\r\n    (props.callback === undefined ? expression : props.callback(expression)) ||\r\n    oldValue.current\r\n  );\r\n};\r\n\r\nexport default AnimatedCounter;\r\n"]},"metadata":{},"sourceType":"module"}